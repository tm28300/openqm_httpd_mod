/* 
 *  mod_openqm.c -- Apache sample openqm module
 *  [Autogenerated via ``apxs -n openqm -g'']
 *
 *  To play with this sample module first compile it into a
 *  DSO file and install it into Apache's modules directory 
 *  by running:
 *
 *    $ apxs -c -i mod_openqm.c
 *
 *  Then activate it in Apache's apache2.conf file for instance
 *  for the URL /openqm in as follows:
 *
 *    #   apache2.conf
 *    LoadModule openqm_module modules/mod_openqm.so
 *    <Location /openqm>
 *    SetHandler openqm
 *    </Location>
 *
 *  Then after restarting Apache via
 *
 *    $ apachectl restart
 *
 *  you immediately can request the URL /openqm and watch for the
 *  output of this module. This can be achieved for instance via:
 *
 *    $ lynx -mime_header http://localhost/openqm 
 *
 *  The output should be similar to the following one:
 *
 *    HTTP/1.1 200 OK
 *    Date: Tue, 31 Mar 1998 14:42:22 GMT
 *    Server: Apache/1.3.4 (Unix)
 *    Connection: close
 *    Content-Type: text/html
 *  
 *    The sample page from mod_openqm.c
 */ 

#include <errno.h>
#include <sys/types.h>

#include <qmdefs.h>
#include <qmclilib.h>

#include <pcre.h>
#include <ctype.h>

#include <httpd.h>
#include <http_config.h>
#include <http_log.h>
#include <http_protocol.h>
#include <ap_config.h>
#include <apr_env.h>
#include <apr_file_io.h> // For apr_file_t
#include <apr_strings.h>
#include <util_script.h>

// Declaration

static int check_openqm_object_name (const char* object_name);
static void string_to_upper (char* string);
static void abort_message (request_rec *r, const char* error_message);
static int extract_routine_name (request_rec *r, char** p_routine_name);

static const char *openqm_set_local_account (cmd_parms *cmd, void *void_cfg, const char *arg);
static void* openqm_create_dir_conf (apr_pool_t *pool, char *context);
static void* openqm_merge_dir_conf (apr_pool_t *pool, void *void_base, void *void_add);
static int openqm_handler (request_rec *r);
static void openqm_register_hooks (apr_pool_t *p);

// Types

typedef struct {
   char local_account [33]; // 32 char max and \0
} openqm_config;

// Globals variables

static const command_rec openqm_directives [] =
{
   AP_INIT_TAKE1("OpenQMLocalAccount", openqm_set_local_account, NULL, RSRC_CONF | ACCESS_CONF, "Local account to connect to OpenQM on local server"),
   { NULL }
};

static openqm_config current_config;

static char error_message_detail [256];

/* Dispatch list for API hooks */
module AP_MODULE_DECLARE_DATA openqm_module = {
   STANDARD20_MODULE_STUFF, 
   openqm_create_dir_conf,/* create per-dir    config structures */
   openqm_merge_dir_conf, /* merge  per-dir    config structures */
   NULL,                  /* create per-server config structures */
   NULL,                  /* merge  per-server config structures */
   openqm_directives,     /* table of config file commands       */
   openqm_register_hooks  /* register hooks                      */
};

// Functions

int check_openqm_object_name (const char* object_name)
{
   pcre *reg_exp;
   const char *error;
   int erroffset;
   size_t nbcar_on = strlen (object_name);
   int prce_status;

   reg_exp = pcre_compile ("^[[:alpha:]][[:alnum:]._-]*$",
         0,
         &error,
         &erroffset,
         NULL) ;
   if (reg_exp == NULL)
   {
      snprintf (error_message_detail, sizeof (error_message_detail), "Object name PCRE compilation failed at offset %d: %s", erroffset, error);
      return -1;
   }
   prce_status = pcre_exec (reg_exp,
         NULL,
         object_name,
         nbcar_on,
         0,
         0,
         NULL,
         0);
   pcre_free (reg_exp);
   if (prce_status < 0)
   {
      if (prce_status == PCRE_ERROR_NOMATCH)
      {
         return 1;
      }
      snprintf (error_message_detail, sizeof (error_message_detail), "Object name PCRE match failed with error %d", prce_status);
      return -1;
   }
   return 0;
}

// String to upper case in place
void string_to_upper (char* string)
{
   size_t nbcar = strlen (string);
   size_t icar;
   for (icar = 0 ; icar < nbcar ; icar++)
   {
      string [icar] = (unsigned char) toupper ((unsigned char) string [icar]);
   }
}

void abort_message (request_rec *r, const char* error_message)
{
   // Only add the error message in log
   ap_log_rerror (APLOG_MARK, APLOG_WARNING, 0, r, "%s", error_message);
}

int extract_routine_name (request_rec *r, char** p_routine_name)
{
   char* uri_part = r->path_info;
   if (*uri_part == '/') ++uri_part;
   if (!*uri_part)
   {
      abort_message (r, "Missing routine name");
      return HTTP_NOT_FOUND;
   }
   // Extrait le nom de la routine
   char* routine_name = QMField (uri_part, "/", 1, 1);
   *p_routine_name = routine_name;
   if (!routine_name || !*routine_name)
   {
      abort_message (r, "Can't extract routine name");
      return HTTP_NOT_FOUND;
   }

   // Contrôle le format du nom de la routine
   int return_value = check_openqm_object_name (routine_name);
   if (return_value != 0)
   {
      if (return_value == 1)
      {
         abort_message (r, "Invalid routine name");
         return HTTP_NOT_FOUND;
      }
      abort_message (r, error_message_detail);
      return HTTP_INTERNAL_SERVER_ERROR;
   }

   string_to_upper (routine_name);
   return 0;
}

const char *openqm_set_local_account (cmd_parms *cmd, void *void_cfg, const char *arg)
{
   openqm_config *cfg = (openqm_config *) void_cfg;
   if (strlen (arg) > 32)
   {
      return "Account name too long (> 32 characters)";
   }
   int return_value = check_openqm_object_name (arg);
   if (return_value != 0)
   {
      if (return_value == 1)
      {
         return "Invalid format for account name";
      }
      return error_message_detail;
   }
   strcpy (cfg->local_account, arg);
   string_to_upper (cfg->local_account);
   return NULL;
}

void* openqm_create_dir_conf (apr_pool_t *pool, char *context)
{
   openqm_config *cfg = apr_pcalloc (pool, sizeof(openqm_config));
   if (cfg) {
      /* Set some default values */
      cfg->local_account [0] = '\0'; // Empty string
   }
   return cfg;
}

void* openqm_merge_dir_conf (apr_pool_t *pool, void *void_base, void *void_add)
{
   openqm_config *base = (openqm_config *) void_base;
   openqm_config *add = (openqm_config *) void_add;
   openqm_config *cfg = openqm_create_dir_conf (pool, NULL);

   strcpy (cfg->local_account, strlen (add->local_account) == 0 ? base->local_account : add->local_account);
   return cfg;
}

int openqm_handler(request_rec *r)
{
   if (strcmp(r->handler, "openqm")) {
      return DECLINED;
   }

   openqm_config *cfg = (openqm_config *) ap_get_module_config(r->per_dir_config, &openqm_module);
   if (! strlen (cfg->local_account))
   {
      abort_message (r, "OpenQM local account not configured");
      return HTTP_INTERNAL_SERVER_ERROR;
   }

   /*
    * 1 AUTH.TYPE -> r->ap_auth_type
    * - CONTENT.LENGTH -> Longueur de la page de retour, généré automatiquement par le serveur
    * - CONTENT.TYPE -> Retourné dans header_out
    * 2 DOCUMENT.ROOT -> r->subprocess_env "DOCUMENT_ROOT" (ap_add_common_vars)
    * 3 GATEWAY.INTERFACE
    * 4 HOSTNAME -> r->hostname
    * 5 apr_table_elts(r->headers_in) pour les variables suivantes
    *  HTTP.ACCEPT -> elts "Accept"
    *  HTTP.ACCEPT.CHARSET
    *  HTTP.ACCEPT.ENCODING -> elts "Accept-Encoding"
    *  HTTP.ACCEPT.LANGUAGE -> elts "Accept-Language"
    *  HTTP.CACHE.CONTROL -> elts "Cache-Control"
    *  HTTP.CONNECTION -> elts "Connection"
    *  HTTP.COOKIE
    *  HTTP.HOST -> elts "Cache-Control"
    *  HTTP.KEEP.ALIVE -> elts "Connection" ~ keep-alive
    *  HTTP.REFERER -> elts "Referer"
    *  HTTP.UA.CPU
    *  HTTP.USER.AGENT -> elts "User-Agent"
    *  HTTP.X.FORWARDED.FOR
    *  HTTP.X.FORWARDED.HOST
    *  HTTP.X.FORWARDED.SERVER
    * 6 PATH.INFO -> r->path_info
    * 7 PATH.TRANSLATED -> r->subprocess_env "PATH_TRANSLATED" (ap_add_cgi_vars)
    * 8 QUERY.STRING -> r->args
    * 9 REMOTE.ADDR -> r->useragent_ip
    * 9 REMOTE.PORT -> r->useragent_addr->port
    * 10 REMOTE.USER -> r->user
    * 11 REQUEST.METHOD -> r->method
    * 12 REQUEST.URI -> r->uri
    * 13 SCRIPT.FILENAME -> r->subprocess_env "SCRIPT_FILENAME" (ap_add_common_vars)
    * 14 SCRIPT.NAME -> r->subprocess_env "SCRIPT_NAME" (ap_add_cgi_vars)
    * 15 SERVER.ADDR -> r->subprocess_env "SERVER_*" (ap_add_common_vars)
    *  SERVER.ADMIN
    *  SERVER.NAME
    *  SERVER.PORT
    *  SERVER.PROTOCOL -> r->subprocess_env "REQUEST_SCHEME" (ap_add_common_vars)
    *  SERVER.SIGNATURE
    *  SERVER.SOFTWARE
    * - UNIQUE.ID
    * - USER.AGENT
    * 16 HTTP.OUTPUT
    * 17 HTTP.STATUS
    * 18 HTTP.HEADER -> (r->headers_in) r->headers_out
    */

   apr_int64_t http_return_code;
   if (r->header_only)
   {
      r->content_type = "text/html";
      http_return_code = OK;
   }
   else
   {
      // Set environment variables
      ap_add_common_vars(r);
      ap_add_cgi_vars(r);

      char* routine_name = NULL;
      int return_code = extract_routine_name (r, &routine_name);
      if (return_code)
      {
         if (routine_name)
         {
            QMFree (routine_name);
         }
         return return_code;
      }

      if (! QMConnectLocal (cfg->local_account))
      {
         snprintf (error_message_detail, sizeof (error_message_detail), "Can't connect to OpenQM account %s: %s", cfg->local_account, QMError ());
         abort_message (r, error_message_detail);
         return HTTP_SERVICE_UNAVAILABLE;
      }

      char* req_auth_type = apr_pstrdup (r->pool, r->ap_auth_type);
      char* req_document_root = apr_pstrdup (r->pool, apr_table_get (r->subprocess_env, "DOCUMENT_ROOT"));
      char* req_gateway_interface = NULL;
      char* req_hostname = apr_pstrdup (r->pool, r->hostname);
      char* req_headers_in = NULL; // Voir ci-après
      char* req_path_info = apr_pstrdup (r->pool, r->path_info);
      char* req_path_translated = apr_pstrdup (r->pool, apr_table_get (r->subprocess_env, "PATH_TRANSLATED"));
      char* req_query_string = NULL; // Voir ci-après
      char* req_remote_info; // Voir ci-après
      char* req_remote_user = apr_pstrdup (r->pool, r->user);
      char* request_method = apr_pstrdup (r->pool, r->method);
      char* request_uri = apr_pstrdup (r->pool, r->uri);
      char* script_filename = apr_pstrdup (r->pool, apr_table_get (r->subprocess_env, "SCRIPT_FILENAME"));
      char* script_name = apr_pstrdup (r->pool, apr_table_get (r->subprocess_env, "SCRIPT_NAME"));
      char* req_server_info = NULL; // Voir ci-après
      char* resp_http_output;
      char resp_http_status [4] = "*3";
      char* resp_headers_out;

      // En-tête reçue
      const apr_array_header_t *header_fields;
      int                      field_number;
      apr_table_entry_t        *header_elts = 0;

      header_fields = apr_table_elts (r->headers_in);
      header_elts = (apr_table_entry_t *) header_fields->elts;
      for (field_number = 0; field_number < header_fields->nelts; field_number++)
      {
         char* new_string = QMReplace (req_headers_in, 1, field_number + 1, 0, header_elts [field_number].key);
         QMFree (req_headers_in);
         req_headers_in = new_string;
         new_string = QMReplace (req_headers_in, 2, field_number + 1, 0, header_elts [field_number].val);
         QMFree (req_headers_in);
         req_headers_in = new_string;
      }

      // Retreive data from POST or GET method
      apr_array_header_t *post_pairs = NULL;
      int post_res;

      post_res = ap_parse_form_data(r, NULL, &post_pairs, -1, HUGE_STRING_LEN);
      if (post_res != OK)
      {
         abort_message (r, "Error when retreive POST data");
         post_pairs = NULL;
      }
      if (post_pairs)
      {
         apr_size_t post_len = 0;

         while (!apr_is_empty_array (post_pairs)) {
            apr_off_t value_len;
            ap_form_pair_t *post_pair = (ap_form_pair_t *) apr_array_pop (post_pairs);

            if (post_len)
            {
               post_len++; // & not before first pair
            }
            post_len += strlen (post_pair->name) + 1; // name=
            apr_brigade_length (post_pair->value, 1, &value_len);
            post_len += value_len;
         }
         req_query_string = apr_palloc (r->pool, post_len + 1);
         req_query_string [0] = '\0'; // Empty string
         post_res = ap_parse_form_data(r, NULL, &post_pairs, -1, HUGE_STRING_LEN);
         while (!apr_is_empty_array (post_pairs)) {
            apr_off_t value_len;
            apr_size_t value_size;
            char* value_buffer;
            ap_form_pair_t *post_pair;

            post_pair = (ap_form_pair_t *) apr_array_pop (post_pairs);
            if (*req_query_string)
            {
               strcat (req_query_string, "&"); // not before irst pair
            }
            strcat (req_query_string, post_pair->name);
            strcat (req_query_string, "=");
            apr_brigade_length (post_pair->value, 1, &value_len);
            value_size = value_len;
            value_buffer = apr_palloc(r->pool, value_size);
            apr_brigade_flatten(post_pair->value, value_buffer, &value_size);
            strncat (req_query_string, value_buffer, value_size);
         }
      }
      else
      {
         req_query_string = apr_pstrdup (r->pool, r->args); // GET method
      }

      // Remote info
      req_remote_info = apr_palloc (r->pool, strlen(r->useragent_ip) + 7); // 7 = ":" + port number (65535) and final "\0"
      sprintf (req_remote_info, "%s %d", r->useragent_ip, r->useragent_addr->port);

      // Server info
      const apr_array_header_t *env_fields;
      apr_table_entry_t        *env_elts = 0;

      env_fields = apr_table_elts (r->subprocess_env);
      env_elts = (apr_table_entry_t *) env_fields->elts;
      int field_dest = 0;
      for (field_number = 0; field_number < env_fields->nelts; field_number++)
      {
         char* key = env_elts [field_number].key;
         char* key_start = QMField (key, "_", 1, 1);
         if (apr_strnatcmp (key_start, "SERVER") == 0 || apr_strnatcmp (key, "REQUEST_SCHEME") == 0)
         {
            field_dest++;
            char* new_string = QMReplace (req_server_info, 1, field_dest, 0, key);
            QMFree (req_server_info);
            req_server_info = new_string;
            new_string = QMReplace (req_server_info, 2, field_dest, 0, env_elts [field_number].val);
            QMFree (req_server_info);
            req_server_info = new_string;
         }
         QMFree (key_start);
      }

      resp_http_output = apr_palloc (r->pool, 65536);
      strcpy (resp_http_output, "*65535");
      resp_headers_out = apr_palloc (r->pool, 16364);
      strcpy (resp_headers_out, "*16383");

      QMCall (routine_name, 
            18,
            req_auth_type,          // 1
            req_document_root,      // 2
            req_gateway_interface,  // 3
            req_hostname,           // 4
            req_headers_in,         // 5
            req_path_info,          // 6
            req_path_translated,    // 7
            req_query_string,       // 8
            req_remote_info,        // 9
            req_remote_user,        // 10
            request_method,         // 11
            request_uri,            // 12
            script_filename,        // 13
            script_name,            // 14
            req_server_info,        // 15
            resp_http_output,       // 16
            resp_http_status,       // 17
            resp_headers_out        // 18
            );

      QMDisconnectAll ();

      // Check if the routine update the status
      if (apr_strnatcmp (resp_http_status, "*3") == 0)
      {
         snprintf (error_message_detail, sizeof (error_message_detail), "The routine %s didn't update http status", routine_name);
         abort_message (r, error_message_detail);
         return HTTP_INTERNAL_SERVER_ERROR;
      }

      // Code de retour
      http_return_code = apr_atoi64 (resp_http_status);
      if (errno || !http_return_code)
      {
         http_return_code = OK;
      }

      // Page web complète
      ap_rwrite (resp_http_output, strlen (resp_http_output), r);

      // En-tête de réponse
      char* header_out_fields = QMExtract (resp_headers_out, 1, 0, 0);
      char* header_out_values = QMExtract (resp_headers_out, 2, 0, 0);
      int field_numbers_hout = QMDcount (header_out_fields, FIELD_MARK_STRING);

      for (field_number = 0 ; field_number < field_numbers_hout ; field_number++) 
      {
         char* temp_field = QMExtract (header_out_fields, 1, field_number, 1);
         char* temp_value = QMExtract (header_out_values, 1, field_number, 1);
         apr_table_set (r->headers_out, temp_field, temp_value);
         if (apr_strnatcmp (temp_field, "Content-Type"))
         {
            ap_set_content_type (r, temp_value);
         }
         QMFree (temp_field);
         QMFree (temp_field);
      }
      QMFree (header_out_fields);
      QMFree (header_out_values);

      QMFree (routine_name);
   }
   return http_return_code;
}

void openqm_register_hooks(apr_pool_t *p)
{
   ap_hook_handler (openqm_handler, NULL, NULL, APR_HOOK_MIDDLE);
}
